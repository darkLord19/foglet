package runner

import (
	"encoding/json"
	"fmt"
	"os/exec"
	"strings"

	"github.com/darkLord19/foglet/internal/ai"
	"github.com/darkLord19/foglet/internal/state"
	"github.com/darkLord19/foglet/internal/task"
)

// Runner orchestrates AI task execution
type Runner struct {
	repoPath  string
	configDir string
	taskStore *task.Store
	state     *state.Store
}

// New creates a new runner
func New(repoPath, configDir string) (*Runner, error) {
	// Create task store
	store, err := task.NewStore(configDir)
	if err != nil {
		return nil, err
	}

	return &Runner{
		repoPath:  repoPath,
		configDir: configDir,
		taskStore: store,
	}, nil
}

// SetStateStore sets the state persistence backend used for session workflows.
func (r *Runner) SetStateStore(store *state.Store) {
	r.state = store
}

// Execute runs a task
func (r *Runner) Execute(t *task.Task) error {
	return r.executeWithRepoPath(r.repoPath, t)
}

// ExecuteInRepo runs a task against an explicit repository path.
func (r *Runner) ExecuteInRepo(repoPath string, t *task.Task) error {
	return r.executeWithRepoPath(repoPath, t)
}

func (r *Runner) executeWithRepoPath(repoPath string, t *task.Task) error {
	// Save initial state
	if err := r.taskStore.Save(t); err != nil {
		return err
	}

	// Create worktree
	if err := r.createWorktree(repoPath, t); err != nil {
		t.SetError(err)
		r.taskStore.Save(t)
		return err
	}

	// Run setup
	if err := r.runSetup(t); err != nil {
		t.SetError(err)
		r.taskStore.Save(t)
		return err
	}

	// Run AI
	if err := r.runAI(t); err != nil {
		t.SetError(err)
		r.taskStore.Save(t)
		return err
	}

	// Validate
	if t.Options.Validate {
		if err := r.runValidation(t); err != nil {
			t.SetError(err)
			r.taskStore.Save(t)
			return err
		}
	}

	// Commit
	if t.Options.Commit {
		if err := r.commitChanges(t); err != nil {
			t.SetError(err)
			r.taskStore.Save(t)
			return err
		}
	}

	// Create PR
	if t.Options.CreatePR {
		if err := r.createPR(t); err != nil {
			t.SetError(err)
			r.taskStore.Save(t)
			return err
		}
	}

	// Mark complete
	t.TransitionTo(task.StateCompleted)
	r.taskStore.Save(t)

	return nil
}

func (r *Runner) createWorktree(repoPath string, t *task.Task) error {
	t.TransitionTo(task.StateSetup)
	r.taskStore.Save(t)

	worktreePath, err := r.createWorktreePath(repoPath, t.Branch)
	if err != nil {
		return err
	}
	t.WorktreePath = worktreePath

	return nil
}

func (r *Runner) runSetup(t *task.Task) error {
	if t.Options.SetupCmd == "" {
		return nil
	}

	cmd := exec.Command("sh", "-c", t.Options.SetupCmd)
	cmd.Dir = t.WorktreePath

	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("setup failed: %w\n%s", err, output)
	}

	return nil
}

func (r *Runner) runAI(t *task.Task) error {
	t.TransitionTo(task.StateAIRunning)
	r.taskStore.Save(t)

	// Get AI tool
	tool, err := ai.GetTool(t.AITool)
	if err != nil {
		return err
	}

	if !tool.IsAvailable() {
		return fmt.Errorf("AI tool %s not available", t.AITool)
	}

	// Execute AI
	result, err := tool.Execute(t.WorktreePath, t.Prompt)
	if err != nil {
		return err
	}

	if !result.Success {
		return fmt.Errorf("AI execution failed: %s", result.Output)
	}

	// Store AI output in metadata
	if t.Metadata == nil {
		t.Metadata = make(map[string]interface{})
	}
	t.Metadata["ai_output"] = result.Output

	return nil
}

func (r *Runner) runValidation(t *task.Task) error {
	if t.Options.ValidateCmd == "" {
		return nil
	}

	t.TransitionTo(task.StateValidating)
	r.taskStore.Save(t)

	cmd := exec.Command("sh", "-c", t.Options.ValidateCmd)
	cmd.Dir = t.WorktreePath

	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("validation failed: %w\n%s", err, output)
	}

	return nil
}

func (r *Runner) commitChanges(t *task.Task) error {
	t.TransitionTo(task.StateCommitted)
	r.taskStore.Save(t)

	// Check if there are changes
	cmd := exec.Command("git", "status", "--porcelain")
	cmd.Dir = t.WorktreePath
	output, _ := cmd.Output()

	if len(output) == 0 {
		// No changes to commit
		return nil
	}

	// Stage all changes
	cmd = exec.Command("git", "add", ".")
	cmd.Dir = t.WorktreePath
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("git add failed: %w", err)
	}

	// Commit with explicit message when provided, otherwise generated message.
	commitMsg := strings.TrimSpace(t.Options.CommitMsg)
	if commitMsg == "" {
		commitMsg = fmt.Sprintf("feat: %s\n\nGenerated by Fog AI task %s", t.Prompt, t.ID)
	}

	cmd = exec.Command("git", "commit", "-m", commitMsg)
	cmd.Dir = t.WorktreePath
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("git commit failed: %w", err)
	}

	return nil
}

func (r *Runner) createPR(t *task.Task) error {
	t.TransitionTo(task.StatePRCreated)
	r.taskStore.Save(t)

	// Use GitHub CLI
	if !commandExists("gh") {
		return fmt.Errorf("gh CLI not available")
	}

	// Create PR
	title := fmt.Sprintf("feat: %s", t.Prompt)
	body := fmt.Sprintf("Generated by Fog AI\n\nTask ID: %s\nAI Tool: %s\n\nPrompt:\n%s",
		t.ID, t.AITool, t.Prompt)

	cmd := exec.Command("gh", "pr", "create",
		"--base", t.Options.BaseBranch,
		"--head", t.Branch,
		"--title", title,
		"--body", body)
	cmd.Dir = t.WorktreePath

	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("create PR failed: %w\n%s", err, output)
	}

	// Store PR URL in metadata
	prURL := strings.TrimSpace(string(output))
	if t.Metadata == nil {
		t.Metadata = make(map[string]interface{})
	}
	t.Metadata["pr_url"] = prURL

	return nil
}

func (r *Runner) GetTask(id string) (*task.Task, error) {
	return r.taskStore.Get(id)
}

func (r *Runner) ListTasks() ([]*task.Task, error) {
	return r.taskStore.List()
}

func (r *Runner) ListActiveTasks() ([]*task.Task, error) {
	return r.taskStore.ListActive()
}

func isGitRepo(path string) bool {
	cmd := exec.Command("git", "-C", path, "rev-parse", "--git-dir")
	return cmd.Run() == nil
}

func commandExists(name string) bool {
	_, err := exec.LookPath(name)
	return err == nil
}

func (r *Runner) createWorktreePath(repoPath, branch string) (string, error) {
	if !isGitRepo(repoPath) {
		return "", fmt.Errorf("not a git repository: %s", repoPath)
	}

	cmd := exec.Command("wtx", "add", "--json", branch)
	cmd.Dir = repoPath

	output, err := cmd.CombinedOutput()
	if err != nil {
		return "", fmt.Errorf("create worktree: %w\n%s", err, output)
	}

	result, err := parseWtxAddOutput(output)
	if err != nil {
		return "", err
	}
	return result.Path, nil
}

type wtxAddOutput struct {
	Name   string `json:"name"`
	Branch string `json:"branch"`
	Path   string `json:"path"`
}

func parseWtxAddOutput(raw []byte) (*wtxAddOutput, error) {
	var out wtxAddOutput
	if err := json.Unmarshal(raw, &out); err != nil {
		return nil, fmt.Errorf("parse wtx add output: %w", err)
	}
	if strings.TrimSpace(out.Path) == "" {
		return nil, fmt.Errorf("parse wtx add output: missing path")
	}
	return &out, nil
}
